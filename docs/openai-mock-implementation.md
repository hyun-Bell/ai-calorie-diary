# OpenAI API 목업 구현: 개발 비용과 테스트 안정성 잡기

*작성일: 2025-06-15*

## 문제 상황

개발을 하다 보면 외부 API에 의존하는 상황이 자주 생긴다. 이 프로젝트에서도 음식 사진을 분석하기 위해 OpenAI API를 사용하고 있었는데, 개발 과정에서 여러 가지 골치 아픈 문제들이 계속 발생했다.

가장 먼저 느낀 건 비용 문제였다. 개발하면서 테스트를 돌릴 때마다 OpenAI API를 호출하니까 요금이 계속 나가는 거다. 한 번 두 번은 괜찮았지만, TDD 방식으로 개발하다 보니 테스트를 수십 번씩 돌리게 되고, 그때마다 API 호출 비용이 발생했다. 특히 이미지 분석 API는 텍스트 API보다 비용이 높아서 더 부담스러웠다.

두 번째로는 테스트 환경의 불안정성이었다. OpenAI API는 외부 서비스이다 보니 네트워크 상태나 API 서버 상황에 따라 응답이 달라지거나 아예 실패하는 경우가 있었다. 이런 상황에서는 내 코드에 문제가 있는 건지, 외부 API 문제인지 구분하기 어려웠다. 무엇보다 테스트가 실패하면 개발 흐름이 중단되는 게 가장 큰 문제였다.

세 번째는 개발 속도의 문제였다. OpenAI API는 이미지 분석이라는 복잡한 작업을 하다 보니 응답 시간이 꽤 걸렸다. 빠를 때는 2-3초, 느릴 때는 10초 이상 걸리기도 했다. 테스트 한 번 돌리는 데 이런 시간이 걸리니까 개발할 때 피드백 루프가 너무 길어졌다.

마지막으로는 테스트 데이터의 일관성 문제였다. 같은 이미지와 설명을 보내도 OpenAI가 매번 조금씩 다른 결과를 돌려주니까, 테스트 결과를 예측하기가 어려웠다. 물론 AI의 특성상 당연한 일이지만, 단위 테스트에서는 예측 가능한 결과가 필요하다.

## 해결 방향 설정

이런 문제들을 보면서 근본적인 해결책이 필요하다고 생각했다. 핵심은 외부 의존성을 어떻게 추상화할 것이냐는 거였다. Clean Architecture에서 말하는 의존성 역전 원칙을 제대로 적용해보기로 했다.

아이디어는 간단했다. OpenAI API 호출 기능을 인터페이스로 추상화하고, 실제 구현체와 목업 구현체를 따로 만드는 거다. 그리고 환경변수를 통해 어떤 구현체를 사용할지 선택할 수 있게 하는 것이었다. 이렇게 하면 개발할 때는 목업을 사용해서 빠르고 안정적으로 테스트할 수 있고, 프로덕션에서는 실제 API를 사용할 수 있을 것 같았다.

다른 방법들도 고려해봤다. 환경변수로 API 키만 비워두는 방법이나, 테스트 시에만 API 호출을 스킵하는 방법 등도 생각해봤는데, 이런 방식들은 결국 임시방편에 불과했다. 제대로 하려면 아키텍처 차원에서 접근해야 한다고 판단했다.

## 구현 과정

### 인터페이스 설계부터

먼저 기존 코드를 살펴봤다. `OpenAIApiAdapter`라는 클래스가 있었고, 이미 Port & Adapter 패턴을 어느 정도 적용하고 있었다. 다행히 `OpenAIApiPort`라는 인터페이스도 이미 정의되어 있어서 추가로 할 일이 많지 않았다.

```typescript
export interface OpenAIApiPort {
  analyzeFood(
    image: Express.Multer.File,
    description: string,
  ): Promise<FoodAnalysis>;
}
```

인터페이스가 깔끔하게 정의되어 있어서 만족스러웠다. 파일과 설명을 받아서 음식 분석 결과를 돌려주는 단순하고 명확한 구조였다.

### 목업 구현체 만들기

다음 단계는 목업 구현체를 만드는 것이었다. 처음에는 단순하게 하드코딩된 데이터만 돌려주는 방식으로 시작했다가, 나중에 좀 더 정교하게 만들었다.

가장 고민됐던 부분은 목업 데이터를 어떻게 구성할 것인가였다. 너무 단순하면 실제 상황과 달라서 테스트 의미가 없을 것 같았고, 너무 복잡하면 관리하기 어려울 것 같았다. 결국 설명 텍스트에 포함된 키워드를 기준으로 다른 데이터를 돌려주는 방식을 선택했다.

```typescript
// 피자, 샐러드, 기본 메뉴 등 시나리오별로 다른 데이터
if (description.includes('피자')) {
  return new FoodAnalysis(/* 피자 관련 데이터 */);
}
```

이렇게 하면 테스트에서 다양한 시나리오를 검증할 수 있을 것 같았다.

### 목업 데이터의 품질 문제

목업을 만들면서 가장 까다로웠던 부분은 데이터의 정확성이었다. 처음에는 대충 만들었다가, 나중에 보니까 칼로리 계산이 맞지 않는 걸 발견했다. 예를 들어 영양소별 칼로리를 다 더하면 450인데 총 칼로리는 480이라고 되어 있는 식이었다.

이런 디테일이 중요한 이유는, 나중에 클라이언트에서 칼로리 계산 검증 로직이 들어갈 수도 있기 때문이다. 목업 데이터라고 해서 대충 만들면 나중에 문제가 될 수 있다.

그래서 영양소 칼로리 계산 공식을 찾아보고 (단백질 1g = 4kcal, 탄수화물 1g = 4kcal, 지방 1g = 9kcal), 실제로 계산해서 맞는 데이터를 만들었다. 이 과정에서 영양학에 대해서도 조금 배우게 되었다.

### 환경변수 기반 전환 로직

다음으로 중요한 건 환경변수를 통해 어떤 구현체를 사용할지 결정하는 로직이었다. NestJS의 Factory 패턴을 사용했다.

```typescript
{
  provide: OpenAIApiPortSymbol,
  useFactory: (configService: ConfigService): OpenAIApiPort => {
    const useMock = configService.get<boolean>('openai.useMock', false);
    return useMock
      ? new OpenAIApiMockAdapter()
      : new OpenAIApiAdapter(configService);
  },
  inject: [ConfigService],
}
```

이렇게 해두면 `USE_MOCK_OPENAI=true`로 설정하면 목업을 사용하고, 그렇지 않으면 실제 API를 사용하게 된다.

## 구현 과정에서 마주한 문제들

### 환경변수 검증의 복잡성

첫 번째로 마주한 문제는 환경변수 검증 로직이 생각보다 복잡하다는 것이었다. `USE_MOCK_OPENAI`가 true일 때는 OpenAI API 키가 없어도 되고, false일 때는 반드시 있어야 한다. 이런 조건부 검증을 Joi로 표현하는 게 쉽지 않았다.

```typescript
OPENAI_API_KEY: Joi.string().when('USE_MOCK_OPENAI', {
  is: false,
  then: Joi.required(),
  otherwise: Joi.optional(),
}),
```

게다가 환경변수는 기본적으로 문자열로 들어오는데, `USE_MOCK_OPENAI`는 boolean 값이어야 한다. 'true'라는 문자열을 true라는 boolean으로 변환하는 로직도 필요했다.

### 목업에서도 에러 처리가 필요하다

두 번째 문제는 목업에서도 에러 시나리오를 다뤄야 한다는 것이었다. 실제 API는 네트워크 오류, 인증 오류, 요청 한도 초과 등 다양한 에러를 던질 수 있다. 목업에서 이런 상황들을 시뮬레이션하지 않으면 에러 처리 로직을 제대로 테스트할 수 없다.

그래서 특정 키워드(예: "에러", "error")가 포함된 요청에 대해서는 의도적으로 에러를 던지도록 했다. 이렇게 하면 에러 처리 로직도 테스트할 수 있다.

### 실제 API와의 일관성 유지

세 번째로는 목업과 실제 API 사이의 일관성을 유지하는 문제였다. OpenAI API의 응답 형식이 바뀌거나, 새로운 필드가 추가되면 목업도 함께 업데이트해야 한다. 이런 부분은 문서화를 통해 해결하기로 했다.

## 완성된 결과물의 개선사항

### 구조화된 목업 데이터

처음에는 목업 데이터를 하드코딩으로 만들었는데, 나중에 별도 파일로 분리해서 관리하기로 했다. `mock-data/food-analysis-scenarios.ts`라는 파일을 만들어서 시나리오별 데이터를 체계적으로 관리한다.

```typescript
export const mockFoodScenarios: MockFoodScenario[] = [
  {
    keywords: ['피자'],
    ingredients: ['피자 도우', '토마토 소스', '모짜렐라 치즈', '페퍼로니'],
    totalCalories: 854, // 영양소 합계와 정확히 일치
    breakdown: { /* 정확한 영양소 정보 */ }
  },
  // 다른 시나리오들...
];
```

이렇게 하니까 새로운 테스트 시나리오를 추가하거나 기존 데이터를 수정하기가 훨씬 쉬워졌다.

### 실제 API 동작 시뮬레이션

목업이라고 해서 즉석에서 결과를 돌려주면 실제 환경과 너무 달라서 문제가 될 수 있다. 실제 OpenAI API는 분석하는 데 시간이 걸리니까, 목업에서도 랜덤한 지연 시간을 추가했다.

```typescript
private async simulateApiDelay(): Promise<void> {
  const delay = Math.random() * 500 + 100; // 100-600ms 랜덤 지연
  await new Promise(resolve => setTimeout(resolve, delay));
}
```

이렇게 하면 실제 환경에서 발생할 수 있는 타이밍 관련 문제들도 어느 정도 테스트할 수 있다.

### 로깅과 디버깅

목업을 사용할 때도 디버깅이 필요할 때가 있다. 어떤 시나리오가 매칭되었는지, 어떤 데이터가 반환되었는지 알 수 있도록 로깅을 추가했다.

```typescript
this.logger.debug(`Mock analysis for: ${description}`);
```

이렇게 해두면 테스트할 때 어떤 목업 시나리오가 실행되었는지 확인할 수 있어서 디버깅이 쉬워진다.

## 결과 분석

### 개발 효율성의 극적인 향상

목업을 도입한 이후의 변화는 정말 극적이었다. 테스트 실행 시간이 10분의 1로 줄어들었다. 이전에는 한 번 테스트 돌리는 데 몇 초씩 걸렸는데, 이제는 거의 즉시 결과가 나온다. TDD 스타일로 개발할 때 이런 빠른 피드백은 정말 중요하다.

비용 측면에서도 확실한 효과가 있었다. 개발 중에는 OpenAI API를 전혀 호출하지 않으니까 비용이 발생하지 않는다. 물론 프로덕션에서는 여전히 실제 API를 사용하니까, 실제 사용자에게는 똑같은 품질의 서비스를 제공할 수 있다.

### 테스트 안정성 확보

가장 큰 변화는 테스트의 안정성이었다. 더 이상 네트워크 상태나 외부 API 서버 상황에 신경 쓸 필요가 없어졌다. 인터넷이 연결되지 않은 상황에서도 테스트를 실행할 수 있고, 항상 일관된 결과를 얻을 수 있다.

특히 CI/CD 파이프라인에서 이런 안정성은 매우 중요하다. 빌드가 실패했을 때 내 코드 문제인지 외부 API 문제인지 헷갈릴 필요가 없어졌다.

### 다양한 시나리오 테스트

목업을 사용하면서 예상치 못한 장점도 있었다. 실제 API로는 테스트하기 어려운 다양한 시나리오들을 쉽게 테스트할 수 있게 된 것이다. 에러 상황, 특정 음식 타입, 극단적인 영양소 값 등을 마음대로 시뮬레이션할 수 있다.

실제 API를 사용한다면 원하는 테스트 케이스를 만들기 위해 특정 이미지를 준비해야 하고, 그것도 항상 원하는 결과가 나온다는 보장이 없다. 목업을 사용하면 이런 제약이 없어진다.

## 핵심 학습 사항

### 외부 의존성 추상화의 중요성

이번 작업을 통해 외부 의존성을 추상화하는 것의 중요성을 다시 한 번 느꼈다. OpenAI 말고 다른 AI 서비스로 바꾸고 싶다면? 새로운 구현체만 만들면 된다. 비즈니스 로직은 전혀 건드릴 필요가 없다.

이런 설계는 단순히 테스트 때문만이 아니라, 장기적인 유지보수성 측면에서도 매우 중요하다. 외부 서비스는 언제든 정책이 바뀔 수 있고, 요금 체계도 변경될 수 있다. 그런 상황에서 빠르게 대응하려면 이런 추상화가 필수다.

### Factory Pattern의 실용성

NestJS의 `useFactory` 패턴을 사용해서 런타임에 조건에 따라 다른 구현체를 주입하는 방식이 정말 유용했다. 이런 패턴을 사용하면 코드 변경 없이 설정만으로 동작을 바꿀 수 있다.

다른 방법으로는 Strategy Pattern이나 Abstract Factory Pattern 등도 고려해볼 수 있었지만, 이 경우에는 NestJS가 제공하는 Factory 패턴이 가장 적합했다.

### 목업 데이터의 품질이 중요하다

목업이라고 해서 대충 만들어도 된다고 생각했는데, 실제로는 그렇지 않았다. 목업 데이터의 품질이 낮으면 테스트의 신뢰성도 떨어진다. 특히 비즈니스 로직에서 데이터 검증을 하는 경우에는 목업 데이터도 그 검증을 통과할 수 있어야 한다.

영양소 계산처럼 실제 도메인 지식이 필요한 부분은 제대로 공부해서 정확한 데이터를 만드는 것이 중요하다.

### 점진적 전환의 안전성

기존 시스템을 한 번에 바꾸지 않고 점진적으로 전환한 것이 좋은 선택이었다. 인터페이스가 이미 있었기 때문에 새로운 구현체만 추가하면 되었고, 기존 코드는 거의 건드리지 않아도 되었다.

이런 접근 방식은 리스크를 최소화하면서도 각 단계에서 검증할 수 있게 해준다. 만약 문제가 생기면 언제든 이전 상태로 되돌릴 수 있다.

## 향후 계획과 확장 가능성

### Feature Flag 도입 검토

지금은 환경변수로만 제어하고 있는데, 나중에는 Feature Flag를 도입해서 런타임에도 전환할 수 있도록 하면 좋을 것 같다. 예를 들어 특정 사용자나 특정 시간대에만 목업을 사용하는 식으로 더 세밀한 제어가 가능할 것이다.

### 다른 AI 서비스 지원

OpenAI 말고 Claude, Gemini 등 다른 AI 서비스도 지원할 수 있도록 확장하는 것도 고려하고 있다. 이미 인터페이스로 추상화되어 있으니까 새로운 구현체만 추가하면 된다.

```typescript
enum AIProvider {
  OPENAI = 'openai',
  CLAUDE = 'claude',
  GEMINI = 'gemini'
}
```

이런 식으로 확장하면 비용이나 성능에 따라 최적의 AI 서비스를 선택할 수 있을 것이다.

### 메트릭 수집

실제 서비스에서는 목업과 실제 API 사용 비율, 응답 시간, 비용 등을 모니터링하는 것도 중요하다. 이런 데이터를 수집해서 최적의 운영 방법을 찾아갈 수 있을 것이다.

## 결론

이번 OpenAI 목업 구현 작업은 단순한 기술적 개선을 넘어서 설계 철학에 대해 다시 생각해보는 계기가 되었다. 외부 의존성을 다룰 때는 항상 "이게 바뀌면 어떻게 될까?"를 고민해야 한다는 걸 다시 한 번 깨달았다.

특히 비용이 발생하는 외부 서비스의 경우에는 개발 단계에서부터 이런 추상화가 더욱 중요하다. 개발자가 부담 없이 테스트할 수 있어야 좋은 코드가 나온다.

Clean Architecture나 SOLID 원칙 같은 것들이 왜 중요한지 이론적으로는 알고 있었지만, 실제로 적용해보니까 그 가치를 몸으로 느낄 수 있었다. 앞으로도 이런 원칙들을 염두에 두고 설계해야겠다.

무엇보다 이런 경험을 문서로 남겨두는 것의 중요성도 느꼈다. 몇 달 후에 비슷한 문제를 마주했을 때, 이 문서를 읽으면 당시의 고민과 해결 과정을 다시 떠올릴 수 있을 것이다.

---

*참고: 목업 데이터의 영양소 계산은 실제 영양학 자료를 참고하여 작성했으나, 의학적 목적으로 사용해서는 안 됩니다.*