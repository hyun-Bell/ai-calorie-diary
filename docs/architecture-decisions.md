# 아키텍처 결정 기록 (ADR)

프로젝트 진행하면서 내린 중요한 아키텍처 결정들을 기록해두는 곳이다.

## ADR-001: Clean Architecture + Hexagonal Architecture 채택

**날짜**: 프로젝트 초기 (2024년 경)

### 상황
NestJS로 칼로리 일기장 API를 만들어야 했는데, 어떤 아키텍처 패턴을 쓸지 고민이었다. 단순히 컨트롤러-서비스-리포지토리 패턴으로 가자니 나중에 유지보수가 어려워질 것 같았고, 그렇다고 너무 복잡한 구조를 만들자니 개발 속도가 느려질 것 같았다.

### 결정
Clean Architecture와 Hexagonal Architecture를 조합한 포트/어댑터 패턴으로 가기로 했다. 각 도메인별로 모듈을 나누고, 그 안에서 어댑터와 포트를 명확히 구분하기로 했다.

### 이유
비즈니스 로직과 프레임워크를 분리해서 NestJS에 종속되지 않게 하고 싶었다. 특히 테스트 용이성을 중요하게 생각했는데, 외부 의존성 없이 비즈니스 로직을 테스트할 수 있어야 한다고 봤다. 또한 나중에 DB나 외부 API를 바꿀 일이 생길 수도 있으니까 확장성도 고려해야 했고, 팀으로 작업할 때 역할별로 코드를 나눠서 작업하기 좋은 구조여야 했다.

### 결과
실제로 모듈별로 깔끔하게 분리가 됐고, 테스트 커버리지도 높아졌다. 새로운 기능을 추가할 때도 기존 코드에 미치는 영향이 적어서 안전하게 개발할 수 있었다. 다만 초기 설정이 좀 복잡했고, 새로운 팀원이 코드 구조를 이해하는 데 시간이 좀 걸렸다.

---

## ADR-002: 파일 저장소 추상화

**날짜**: 2025-06-16

### 상황
테스트할 때마다 S3에 실제로 파일을 업로드하고 있어서 느리고 비용도 나가고 있었다. 테스트 실행 시간이 길어지니까 개발 흐름이 자꾸 끊어지고, 무엇보다 외부 의존성 때문에 인터넷이 없으면 테스트가 실패하는 상황이었다.

### 결정
FileStorageService 인터페이스를 만들어서 파일 저장소를 추상화하기로 했다. 테스트 환경에서는 로컬 파일시스템을 사용하고, 프로덕션에서는 S3를 사용하는 방식으로 환경에 따라 다른 구현체를 주입하기로 했다.

### 이유
테스트 성능을 개선해서 로컬 파일시스템을 사용하면 훨씬 빨라질 거라고 생각했다. 테스트용 S3 API 호출을 제거하면 비용도 절약할 수 있고, 외부 의존성 없는 독립적인 테스트가 가능해져서 테스트 격리도 완성될 거였다. 게다가 나중에 다른 클라우드 저장소로 변경하기도 쉬워질 것 같았다.

인터페이스 정의는 간단하게 uploadFile과 deleteFile 메서드만 만들었고, 환경별 주입은 useFactory를 사용해서 NODE_ENV가 test면 LocalFileStorageService를, 아니면 S3Service를 반환하도록 했다.

### 결과
테스트 실행 시간이 확실히 단축됐고, 테스트 비용도 0원이 됐다. 새로운 저장소를 추가할 때도 기존 코드 변경이 최소화되니까 확장성도 좋아졌다. 다만 초기 구현 시에 인터페이스를 DI 토큰으로 사용할 수 없다는 걸 깨닫고 별도 토큰을 만들어야 했고, 기존 테스트들을 모두 업데이트하는 작업이 필요했다.

---

## ADR-003: 이벤트 기반 모듈 간 통신

**날짜**: 프로젝트 초기

### 상황
Food 모듈에서 분석한 결과를 Diary 모듈에서 사용해야 했는데, 직접 의존성을 만들고 싶지 않았다. Food 모듈이 Diary 모듈을 직접 호출하게 되면 두 모듈이 강하게 결합되고, 나중에 하나를 수정할 때 다른 쪽에도 영향을 줄 수 있을 것 같았다.

### 결정
In-memory Event Bus를 사용한 이벤트 기반 통신으로 가기로 했다. Food 모듈에서 분석이 완료되면 FoodAnalyzedEvent를 발행하고, Diary 모듈에서 그 이벤트를 수신해서 처리하는 방식으로 했다.

### 이유
각 모듈이 서로를 직접 알 필요 없이 독립성을 유지할 수 있어서 좋을 것 같았다. 새로운 이벤트 리스너를 추가하기도 쉽고, 테스트할 때도 이벤트만 확인하면 되니까 용이할 거라고 생각했다. 특히 나중에 다른 모듈에서도 Food 분석 결과를 사용하고 싶을 때 추가적인 이벤트 리스너만 만들면 되니까 확장성도 좋아 보였다.

### 결과
Food 분석이 완료되면 FoodAnalyzedEvent가 발행되고, Diary 모듈에서 이벤트를 수신해서 자동으로 다이어리를 생성하는 구조가 잘 작동했다. 각 모듈을 독립적으로 개발하고 테스트할 수 있어서 개발 효율성도 좋아졌다. 다만 이벤트 기반 통신은 디버깅이 좀 어렵고, 이벤트 흐름을 파악하기 위해 별도 문서화가 필요했다.

---

## 미래의 결정들

### 고려 중인 것들
현재 캐싱 전략을 고민하고 있다. Redis를 사용할지, In-memory 캐싱을 할지, 아니면 Database 레벨에서 해결할지 결정해야 한다. 이미지 처리도 Sharp를 계속 쓸지, ImageMagick으로 바꿀지, 아니면 Cloud Function으로 외부화할지 생각 중이다.

로그 관리도 중요한 이슈인데, ELK Stack을 구성할지, CloudWatch를 쓸지, Grafana Loki를 도입할지 고민이다. API 문서화도 현재 Swagger를 쓰고 있는데, OpenAPI Generator로 자동 생성하는 방법이나 별도 문서 사이트를 만드는 것도 검토하고 있다.

### 나중에 결정할 것들
마이크로서비스로 분할할 기준도 정해야 하고, 실시간 알림 시스템도 WebSocket을 쓸지 Server-Sent Events를 쓸지 결정해야 한다. AI 모델 업그레이드 전략도 중요한데, 이건 서비스가 좀 더 안정화되고 나서 고민해봐야 할 것 같다.

---

*결정을 내릴 때마다 여기에 기록해두자. 나중에 왜 이렇게 했는지 까먹을 수 있으니까.*