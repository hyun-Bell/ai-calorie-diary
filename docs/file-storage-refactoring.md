# 파일 저장소 리팩토링: 테스트 환경에서 S3 의존성 제거하기

*작성일: 2025-06-16*

## 문제 상황

많은 프로젝트에서 파일 저장소로 AWS S3를 사용하게 되는데, 이때 흔히 마주하게 되는 문제가 있다. 바로 테스트 환경에서도 실제 S3에 파일을 업로드하게 되면서 발생하는 여러 가지 부작용들이다.

이 프로젝트에서도 동일한 문제가 발생했다. 테스트를 실행할 때마다 AWS API를 호출하여 실제 S3 버킷에 파일을 업로드하고 있었다. 이로 인해 테스트 실행 시간이 느려지고, 인터넷 연결이 필수가 되며, S3 사용료가 지속적으로 발생하는 상황이었다. 무엇보다 개발 흐름이 자주 중단되는 문제가 있었다.

구체적인 문제점들을 정리하면 다음과 같다. 첫째, S3 API 호출로 인한 테스트 실행 시간 지연이었다. 둘째, 테스트 실행 시마다 발생하는 클라우드 비용이었다. 셋째, 외부 의존성으로 인한 테스트 환경의 불안정성이었다. 마지막으로 실제 S3에 파일이 계속 누적되어 테스트 격리가 제대로 이루어지지 않는 문제였다. 이러한 상황은 명백한 안티패턴으로 볼 수 있었다.

## 해결 방향 설정

이런 문제를 해결하기 위해서는 근본적인 설계 개선이 필요했다. 핵심은 추상화를 통한 의존성 역전이었다. 파일 저장소 기능을 인터페이스로 추상화하고, 환경에 따라 서로 다른 구현체를 주입하는 방식을 채택하기로 했다.

구체적으로는 테스트 환경에서는 로컬 파일시스템을 사용하는 구현체를, 프로덕션 환경에서는 S3를 사용하는 구현체를 주입하는 방식이다. 이렇게 하면 Clean Architecture의 포트/어댑터 패턴을 제대로 적용할 수 있을 뿐만 아니라, 테스트 성능도 크게 개선할 수 있을 것으로 예상되었다.

## 구현 과정

### 인터페이스 설계

먼저 파일 저장소의 핵심 기능을 추상화한 `FileStorageService` 인터페이스를 정의했다. 복잡한 기능보다는 필수적인 두 가지 메서드에 집중했다. `uploadFile` 메서드는 파일 업로드를 담당하며, 선택적으로 파일 키를 받을 수 있도록 설계했다. `deleteFile` 메서드는 파일 삭제 기능을 제공한다.

```typescript
export interface FileStorageService {
  uploadFile(file: Express.Multer.File, key?: string): Promise<string>;
  deleteFile(key: string): Promise<void>;
}
```

### 로컬 파일 저장소 구현

다음으로 테스트 환경에서 사용할 `LocalFileStorageService`를 구현했다. 이 클래스는 파일을 로컬 파일시스템에 저장하는 역할을 한다. `uploadFile` 메서드는 파일 키가 제공되면 그것을 사용하고, 그렇지 않으면 타임스탬프와 랜덤 문자열을 조합하여 유니크한 파일명을 생성한다.

파일은 프로젝트 루트의 `uploads` 디렉토리에 저장되며, 반환되는 URL은 `file://` 스킴을 사용한다. 이러한 방식을 통해 테스트 실행 시에는 실제 파일시스템에 저장되지만 S3 API는 전혀 호출되지 않는다.

### 기존 S3Service 수정

기존의 `S3Service`도 새로운 인터페이스를 구현하도록 수정했다. 이는 기존 코드의 변경을 최소화하면서도 추상화를 적용할 수 있는 방법이었다. 메서드 시그니처만 약간 조정하면 되므로 변경 범위가 매우 제한적이었다.

### 환경별 의존성 주입

가장 중요한 부분은 `StorageModule`에서 환경에 따라 적절한 구현체를 주입하는 로직이었다. NestJS의 `useFactory` 패턴을 활용하여 `NODE_ENV` 환경 변수를 기준으로 구현체를 선택하도록 했다. 테스트 환경에서는 `LocalFileStorageService`를, 그 외의 환경에서는 `S3Service`를 반환한다.

## 구현 과정에서 발생한 문제들

### TypeScript 인터페이스의 런타임 제약

첫 번째로 마주한 문제는 TypeScript의 특성에서 비롯된 것이었다. `FileStorageService` 인터페이스를 DI 토큰으로 직접 사용하려고 했으나 실패했다. TypeScript의 인터페이스는 컴파일 타임에만 존재하고 런타임에는 존재하지 않기 때문이다. 이를 해결하기 위해 `FILE_STORAGE_SERVICE_TOKEN`이라는 문자열 상수를 별도로 정의하여 사용했다.

### 기존 테스트 코드 업데이트

두 번째 문제는 기존 테스트 코드들의 대대적인 수정이 필요하다는 점이었다. 이전에는 `S3Service`를 직접 모킹하고 있었는데, 이제는 새로운 토큰을 사용해야 했다. 모든 단위 테스트와 E2E 테스트 파일을 하나씩 점검하고 업데이트하는 작업이 필요했다. 단순한 작업이지만 빠뜨리면 안 되는 중요한 과정이었다.

### E2E 테스트의 추가 수정

세 번째로, E2E 테스트에서도 동일한 문제가 발생했다. 단위 테스트를 모두 수정했음에도 불구하고 E2E 테스트에서는 여전히 이전 방식으로 모킹하고 있어서 테스트가 실패했다. 다행히 테스트 실패를 통해 이 문제를 빠르게 발견하고 수정할 수 있었다.

## 결과 분석

### 개선된 측면들

리팩토링 이후의 변화는 매우 명확했다. 테스트 실행 시간이 로컬 파일시스템 사용으로 인해 현저히 단축되었다. 외부 의존성이 완전히 제거되어 인터넷 연결 없이도 테스트를 실행할 수 있게 되었다. 비용 측면에서는 테스트로 인한 S3 요금이 완전히 사라졌다. 가장 중요한 것은 로컬 `uploads` 폴더를 사용함으로써 완벽한 테스트 격리가 가능해진 점이다.

### 검증 결과

실제로 모든 단위 테스트와 E2E 테스트가 통과했으며, 테스트 실행 중에 생성된 파일들이 로컬 `uploads` 폴더에 저장되는 것을 확인할 수 있었다. 이는 새로운 시스템이 정상적으로 작동하고 있음을 보여주는 명확한 증거였다.

## 핵심 학습 사항

### 의존성 역전 원칙의 위력

이번 리팩토링을 통해 의존성 역전 원칙(Dependency Inversion Principle)의 실질적인 가치를 체험할 수 있었다. 단순히 인터페이스 하나를 도입했을 뿐인데, 시스템의 유연성이 크게 향상되었다. 구체적인 구현체에 의존하지 않고 인터페이스에 의존하게 만듦으로써 이러한 설계 개선이 가능했다.

### 테스트 주도 설계의 중요성

테스트하기 어려운 코드는 대부분 설계에 문제가 있다는 것을 다시 한 번 확인했다. 테스트가 쉬워지자 자연스럽게 더 좋은 아키텍처가 만들어졌다. 이는 테스트 우선 설계(Test-Driven Design)의 중요성을 보여주는 사례라고 할 수 있다.

### Factory Pattern의 활용

NestJS의 `useFactory` 패턴을 통해 런타임에 조건에 따라 다른 인스턴스를 생성하는 방법의 우아함을 경험했다. 이러한 접근 방식은 환경별로 다른 구현체를 주입해야 하는 상황에서 매우 유용하다.

### 점진적 리팩토링의 안전성

기존 코드를 한 번에 모두 변경하지 않고, 인터페이스를 먼저 도입한 후 점진적으로 적용한 방식이 효과적이었다. 이는 리스크를 최소화하면서도 각 단계에서 테스트를 통해 변경 사항을 검증할 수 있게 해주었다.

## 향후 확장 가능성

이제 파일 저장소 시스템이 완전히 추상화되었으므로, 새로운 클라우드 저장소 서비스로의 전환이 매우 쉬워졌다. Google Cloud Storage, Azure Blob Storage, 또는 MinIO와 같은 오픈소스 솔루션으로 전환하고 싶다면, 새로운 구현체만 작성하면 된다. 기존 비즈니스 로직은 전혀 수정할 필요가 없다.

테스트 성능 개선도 추가적인 이점이다. 빨라진 테스트는 TDD(Test-Driven Development) 방식의 개발을 더욱 수월하게 만들어준다. 테스트 피드백 루프가 단축되면서 전체적인 개발 생산성 향상을 기대할 수 있다.

## 결론

이번 리팩토링은 단순한 기술적 개선을 넘어서 설계 철학의 중요성을 보여주는 사례였다. 외부 의존성을 다룰 때는 항상 추상화를 고려해야 한다는 교훈을 얻었다. 클라우드 서비스든 외부 API든, 이들은 언제든 변경될 수 있기 때문에 인터페이스를 통한 의존성 역전이 현명한 선택이다.

시니어 개발자로서 단순히 기능 구현에만 집중하는 것이 아니라, 장기적인 유지보수성과 테스트 가능성을 고려한 설계를 하는 것이 얼마나 중요한지 다시 한 번 깨달을 수 있었다. 이번 경험을 통해 Clean Architecture의 실질적인 가치를 몸소 체험할 수 있었다.

---

*참고: 이 프로젝트에서 테스트 시 생성되는 uploads 폴더는 .gitignore에 포함되어 있으므로 버전 관리에는 영향을 주지 않습니다.*